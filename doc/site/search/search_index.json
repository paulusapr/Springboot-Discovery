{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-nodejs","title":"What is Node.js?","text":"<p>NodeJS is a runtime environment for executing JavaScript outside the browser, built on the V8 JavaScript engine. It enables server-side development, supports asynchronous, event-driven programming, and efficiently handles scalable network applications.</p> <p>NodeJS is single-threaded, utilizing an event loop to handle multiple tasks concurrently. It is asynchronous and non-blocking, meaning operations do not wait for execution to complete. The V8 engine compiles JavaScript to machine code, making NodeJS fast and efficient.</p>"},{"location":"#environment-setup","title":"Environment Setup","text":""},{"location":"#installing-nodejs-and-npm","title":"Installing Node.js and npm","text":"<p>To start with NodeJS we need to install and setup on our machine, at Photon we use MacOS operating system, and we will use MacOS method for installation.</p>"},{"location":"#what-is-npm","title":"What is NPM?","text":"<p>NPM (Node Package Manager) is a package manager for NodeJS that helps developers install, share, and manage libraries and tools required for their NodeJS application. It\u2019s an integral part of the NodeJS ecosystem and is automatically installed along with NodeJS. Other option from NPM we can use Yarn.</p>"},{"location":"#what-is-yarn","title":"What is YARN?","text":"<p>Yarn is established open-source package manager use to manage dependencies in JavaScript project. It assists with the process of installing, updating, configuring and removing packages dependencies, eventually helping you reach your objectives faster with fewer distractions.</p> <p>Yarn focus of speed, correctness, security, and developer experience which we improve along every axis by leveraging a suite of innovative features such as workspaces, offline caching, parallel installs, hardened mode, interactive commands and more.</p>"},{"location":"#what-will-we-use","title":"What will we use?","text":"<p>At Node JS Technical Discovery, will use NPM and installation method using Homebrew:</p> <p>Install Node.js using Homebrew:</p> <p>Homebrew is the most common package manager used on MacOS for managing open-source software. It\u2019s easy to use and ensures that you get the last stable version of Node.js. Let\u2019s check them step-by-step to download Node.js.</p> <ol> <li>Install Homebrew</li> </ol> <p>Open Terminal and run the following command to install homebrew latest version</p> <pre><code>/bin/bash -c \"$(curl \u2013fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <ol> <li>Update brew</li> </ol> <p>Once Homebrew is installed, make sure it\u2019s up to date by using the following command:</p> <pre><code>Brew update // Output e.g: Already up to date\n</code></pre> <ol> <li>Proceed to Install Node.Js</li> </ol> <p>Now run the following command to install Node.js:</p> <pre><code>Brew install node // Output e.g: node 23.10.0_1 is already installed and up-to-date.\n</code></pre> <p>Uninstall Node.js on MacOS:</p> <p>Remove Node.js using Homebrew using the following command:</p> <pre><code>brew uninstall node\n</code></pre>"},{"location":"#verifying-installation","title":"Verifying Installation","text":"<p>Now run the following command to verify the installation:</p> <pre><code>node \u2013v // Output e.g: v23.9.0\n\nnpm \u2013v // Output e.g: 10.9.2\n</code></pre>"},{"location":"#understanding-nodejs-architecture","title":"Understanding Node.js Architecture","text":""},{"location":"#event-driven-architecture","title":"Event-Driven Architecture","text":""},{"location":"#non-blocking-io","title":"Non-blocking I/O","text":""},{"location":"#basic-nodejs-application","title":"Basic Node.js Application","text":"<p>Writing a Basic \u201cHello World\u201d Program</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before you start, ensure you have the following installed:</p> <pre><code>- Node.js (Download and install the latest LTS version)\n\n- A code editor (e.g., VS Code)\n\n- A terminal or command prompt\n</code></pre>"},{"location":"#step-1-initialize-a-new-nodejs-project","title":"Step 1: Initialize a New Node.js Project","text":"<p>Open your terminal and create a new directory for your project:</p> <pre><code>mkdir my-node-app\ncd my-node-app\n</code></pre> <p>Initialize a new Node.js project:</p> <pre><code>npm init -y\n</code></pre> <p>This creates a package.json file with default configurations.</p>"},{"location":"#step-2-create-an-entry-file","title":"Step 2: Create an Entry File","text":"<p>Create a new file named index.js in your project folder.</p> <p>Open index.js and add the following code:</p> <pre><code>console.log(\"Hello, Node.js!\");\n</code></pre>"},{"location":"#step-3-run-the-application","title":"Step 3: Run the Application","text":"<p>In the terminal, navigate to your project folder (if not already inside it).</p> <p>Run the application using Node.js:</p> <pre><code>node index.js // Output e.g: Hello, Node.js!\n</code></pre>"},{"location":"#step-4-using-an-http-server","title":"Step 4: Using an HTTP Server","text":"<p>To create a simple HTTP server, update index.js with the following code:</p> <pre><code>const http = require(\"http\");\n\nconst server = http.createServer((req, res) =&gt; {\n  res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n  res.end(\"Hello, World!\\n\");\n});\n\nserver.listen(3000, () =&gt; {\n  console.log(\"Server running at http://localhost:3000/\");\n});\n</code></pre> <p>Run the server:</p> <pre><code>node index.js\n</code></pre> <p>Open your browser and visit http://localhost:3000/ to see Hello, World!.</p> <p>Running your First Node.js Script</p>"},{"location":"#step-5-installing-and-using-external-packages","title":"Step 5: Installing and Using External Packages","text":"<p>Node.js applications often use external packages. You can install packages using npm (Node Package Manager).</p> <p>Installing Express.js</p> <p>Express.js is a popular web framework for Node.js. Install it using:</p> <pre><code>npm install express\n</code></pre> <p>Creating an Express Server</p> <p>Replace the contents of index.js with:</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.get(\"/\", (req, res) =&gt; {\n  res.send(\"Hello from Express!\");\n});\n\nconst PORT = 3000;\napp.listen(PORT, () =&gt; {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n</code></pre> <p>Run the application:</p> <pre><code>node index.js\n</code></pre> <p>Visit http://localhost:3000/ in your browser to see the response.</p>"},{"location":"#step-6-using-environment-variables","title":"Step 6: Using Environment Variables","text":"<p>To manage configurations, use environment variables. Install dotenv:</p> <pre><code>npm install dotenv\n</code></pre> <p>Create a .env file:</p> <pre><code>PORT=4000\n\nModify index.js to use environment variables:\n\nrequire(\"dotenv\").config();\nconst express = require(\"express\");\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\napp.get(\"/\", (req, res) =&gt; {\nres.send(\"Hello, Express with dotenv!\");\n});\n\napp.listen(PORT, () =&gt; {\nconsole.log(`Server is running on http://localhost:${PORT}`);\n});\n</code></pre> <p>Run:</p> <pre><code>node index.js\n</code></pre> <p>Now, the app will run on port 4000.</p>"},{"location":"#step-7-working-with-a-simple-api","title":"Step 7: Working with a Simple API","text":"<p>You can extend your Node.js application to serve an API:</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.use(express.json());\n\nlet users = [\n  { id: 1, name: \"Alice\" },\n  { id: 2, name: \"Bob\" },\n];\n\napp.get(\"/users\", (req, res) =&gt; {\n  res.json(users);\n});\n\napp.post(\"/users\", (req, res) =&gt; {\n  const newUser = req.body;\n  newUser.id = users.length + 1;\n  users.push(newUser);\n  res.json(newUser);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () =&gt; {\n  console.log(`API running on http://localhost:${PORT}`);\n});\n</code></pre> <p>Test using a tool like Postman or cURL.</p>"},{"location":"#conclusion","title":"Conclusion","text":"<p>You have successfully set up and run a basic Node.js application, created an HTTP server, installed external packages, used environment variables, and built a simple API. You can now explore more features like connecting to a database, using authentication, and deploying your app. Happy coding!</p>"},{"location":"#modules-in-nodejs","title":"Modules in Node.js","text":"<p>In Node.js, modules provide a way to encapsulate functionality and dependency management. modules are reusable pieces of code that can be imported and exported across different files.</p> <p>Example usage:</p> <pre><code>const http = require(\"http\");\n\nconst server = http.createServer(function (\\_req, res) {\nres.writeHead(200);\nres.end(\"Hello, World!\");\n});\nserver.listen(8080);\n</code></pre> <p>Here we import the http module to create a simple NodeJS server. The http module is identified by require() via the string \u201chttp\u201d which always points to the NodeJS internal module.</p> <p>Note how the result of require(\"http\") is handled like every other function invocation. It is basically written to the local constant http.</p> <p>Node.js has many built-in modules that are part of the platform and comes with Node.js installation. Here several Nodejs core modules:</p>"},{"location":"#http-module","title":"Http Module","text":"<p>This module allows you to create HTTP servers and clients. You can use it to handle incoming requests, send responses, and set up a server. It forms the foundation for web applications built with Node.js.</p>"},{"location":"#fs-module","title":"Fs Module","text":"<p>The FS module provides functionality for interacting with the file system. It allows you to read, write, and manipulate files. Key methods include fs.readFile, fs.writeFile, and fs.appendFile. Synchronous methods are also available (e.g., fs.readFileSync).</p>"},{"location":"#path-module","title":"Path Module","text":"<p>The Path module is useful for working with file and directory paths in a cross-platform manner. It provides utilities to manipulate paths, like path.join, path.resolve, and path.basename, helping ensure compatibility across different operating systems.</p>"},{"location":"#url-module","title":"Url Module","text":"<p>The URL module allows you to parse and format URLs. It provides methods to construct URLs, update query parameters, and work with URL components (like protocol, host, pathname).</p>"},{"location":"#os-module","title":"OS Module","text":"<p>This module provides operating system-related utility methods. You can retrieve information related to the OS, such as architecture, free memory, and network interfaces, using functions like os.platform, os.cpuInfo, and os.freemem.</p>"},{"location":"#events-module","title":"Events Module","text":"<p>The Events module enables you to work with event-driven programming. It provides an EventEmitter class that allows you to create and manage events within your application, listening and responding to custom events.</p>"},{"location":"#working-with-package-in-nodejs","title":"Working with Package in Node.js","text":""},{"location":"#what-is-npm-node-package-manager","title":"What is NPM (Node Package Manager)?","text":"<p>NPM is the default package manager for the Node.js. It helps the user to manage the JavaScript packages, libraries and dependencies efficiently. NPM enable us to install, update and manage the packages for the Node.js.</p> <p>Here are some necessary key commands:</p> <ul> <li> <p><code>npm init</code>: This initializes a new Node.js project by creating a package.json file, which stores information about the project, dependencies, scripts, etc. You can run this command in your project directory, and it will prompt you for project details like name, version, and entry point.</p> </li> <li> <p><code>npm install</code>: This command is primarily used to install packages. You may specify <code>--save</code> to add the package as a dependency in your <code>package.json</code> file or <code>--save-dev</code> for development-only dependencies. For example:</p> </li> </ul> <pre><code>   npm install &lt;package-name&gt; --save (for production dependencies)\n   npm install &lt;package-name&gt; --save-dev (for development dependencies)\n</code></pre> <ul> <li> <p><code>npm start</code>: This executes the \"start\" script defined in your package.json file. It's a shorthand that allows you to run the project easily, and you can customize what this script does.</p> </li> <li> <p><code>npm run &lt;script-name&gt;</code>: For any custom scripts that you define in your package.json, you can use this command to execute them. For example, if you have a script called \"test\", you would run npm run test.</p> </li> <li> <p><code>npm uninstall &lt;package-name&gt;:</code> Removes a package from your project. You can also use flags like --save to update your package.json accordingly.</p> </li> </ul>"},{"location":"#installing-package-with-npm","title":"Installing Package with npm","text":"<p>To install a package using NPM, follow these steps:</p> <p>Open the Terminal: Navigate to the project directory where you want to install the package.</p> <p>Run the Installation Command: Use the command:</p> <p><code>npm install &lt;package-name&gt;</code></p> <p>For instance:</p> <pre><code>npm install express\n</code></pre> <p>Updating package.json: Installed packages will automatically be added to your package.json file as dependencies. As of NPM version 5.0.0, packages are saved as dependencies by default, so you no longer need to use <code>--save</code> explicitly.</p> <p>Installing Specific Versions: If you need a specific version, you can specify it like this:</p> <p><code>npm install &lt;package-name&gt;@&lt;version&gt;</code></p> <p>For instance:</p> <pre><code>npm install express@4.17.1\n</code></pre> <p>Check Installed Packages: After installation, you can check the node_modules folder and package.json to confirm that your package was installed successfully. Using NPM simplifies managing dependencies in your Node.js projects, making it easy to install, update, and maintain packages. If you want to explore or search for packages, you can visit the official NPM repository page at npmjs.com.</p>"},{"location":"#managing-dependencies-with-packagejson","title":"Managing Dependencies with Package.json","text":"<p>Managing dependencies in Node.js with package.json is crucial for maintaining your project's organization and ensuring that all required packages are easily installed across different environments. Here are some key points on how to manage dependencies effectively:</p> <ul> <li> <p>Creating package.json: You can create a package.json file by running: npm init</p> </li> <li> <p>Installing Dependencies: When you install packages using: npm install  <li> <p>Development vs. Production Dependencies: You can differentiate between production and development dependencies:</p> </li> <pre><code>    Use npm install &lt;package-name&gt; --save for a production dependency.\n\n    Use npm install &lt;package-name&gt; --save-dev for a development dependency, which is used for tools only needed during development (like testing frameworks).\n</code></pre> <ul> <li> <p>The Role of package-lock.json: This file locks the versions of the installed packages, ensuring that installations are reproducible. It\u2019s automatically created and updated when you install packages.</p> </li> <li> <p>Sharing Projects: When you share your project (e.g., on GitHub), you typically don't need to include the node_modules directory. Instead, after cloning the repository, run: npm install. This installs all dependencies listed in package.json on the new machine.</p> </li> </ul>"},{"location":"#asynchronous-programming-in-nodejs","title":"Asynchronous Programming in Node.js","text":"<p>Asynchronous programming is a style of programming where operations do not wait for the previous one to complete before starting. Instead, the operations are started and completed independently, and the program can continue executing other tasks while waiting for specific operation to finish.</p> <p>Node.js built on asynchronous, event-driven architecture, is specially designed to excel in high concurrency and responsiveness scenarios. Its non-blocking I/O model, combined with the single-threaded event loop, allows Node.js to efficiently handle thousands of concurrent connections without getting blocked by I/O operations.</p> <p>By leveraging asynchronous programming in Node.js, developers can build highly performant and scalable applications. They can offload time-consuming tasks to the background, utilize resources efficiently, and respond to user requests without unnecessary delay.</p>"},{"location":"#understanding-callbacks","title":"Understanding Callbacks","text":"<p>In Node.js, many operations are asynchronous by nature. Node.js uses callbacks to handle asynchronous code. A callback function passes an argument to another function and is called once the operation is completed. The callback function handles the result of operation.</p> <p>Callback example:</p> <pre><code>const fs = require(\"fs\");\nfs.readFile(\"example.txt\", \"utf8\", (err, data) =&gt; {\n  if (err) {\n    console.log(\"Error reading the file\", err);\n    return;\n  }\n  console.log(\"File contents:\", data);\n});\nconsole.log(\"This message will log first, even before file reading completes.\");\n</code></pre> <p>Explanation:</p> <ul> <li> <p>The readFile() function is asynchronous. It starts reading the file but does not wait for the file to be read before moving on.</p> </li> <li> <p>The callback function is provided as the third argument. Once the file is read, this callback is invoked with either an error (err) or the file data (data).</p> </li> <li> <p>The message \u201cThis message will log first...\u201d will appear before the file contents, because readFile() is asynchronous and the event loop continues without waiting for it to finish.</p> </li> </ul>"},{"location":"#promises-in-nodejs","title":"Promises in Node.js","text":"<p>Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises are much cleaner than callbacks and avoid \u201ccallback hell\u201d.</p> <p>A promise is in one of three states:</p> <ul> <li>Pending: The initial state before the operation is complete.</li> <li>Fulfilled: The operation completed successfully.</li> <li>Rejected: The operation failed, and an error occurred.</li> </ul> <p>Creating and using promises</p>"}]}